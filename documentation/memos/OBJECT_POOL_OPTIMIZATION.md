# 对象池优化计划

本文记录 Space Invaders 游戏的对象池（Object Pool）性能优化方案，包括基线测试、优化方案、实施步骤和效果对比。

---

## 一、优化前性能基线

### 背景
当前代码每次射击都创建新的子弹对象，射击停止时销毁对象。这种做法会导致：
- 频繁的内存分配/释放
- 垃圾回收（GC）压力增大
- 性能下降（尤其是子弹数量多时）

### 基线测试方法

#### 工具：浏览器 DevTools Performance Profiler

**准备工作**：
1. 启动开发服务器：`npm start`
2. 打开游戏：http://localhost:8080
3. 按 F12 打开 DevTools

**测试流程**：
1. 点击 `Performance` 标签
2. 点击录制按钮（圆形红点）
3. **在游戏中操作**：
   - 疯狂按空格键 30 秒（尽可能快地射击）
   - 保持玩家飞船移动
   - 目标：最大化子弹创建/销毁频率
4. 停止录制
5. 分析性能曲线

#### 关键指标记录

在下方表格中填入测试数据：

| 指标 | 说明 | 数值 |
|------|------|------|
| **平均 FPS** | 性能曲线中的平均帧率 | `___` |
| **最低 FPS** | 性能曲线中的最低帧率（卡顿点） | `___` |
| **GC 事件数** | Performance 中看到的垃圾回收事件（绿色向下箭头）数量 | `___` |
| **Peak Memory** | 内存占用峰值（MB） | `___` |
| **Avg Memory** | 内存占用平均值（MB） | `___` |

#### 截图位置

- **优化前 FPS 曲线**：粘贴截图或描述
  ```
  [截图位置]
  ```

- **优化前 GC 事件密度**：粘贴截图或描述
  ```
  [截图位置]
  ```

- **优化前内存占用**：粘贴截图或描述
  ```
  [截图位置]
  ```

---

## 二、优化方案概述

### 核心思想：预创建 + 复用

**问题代码**（`GameScene.js`）：
```
playerShoot() 第 179 行：
  const bullet = this.playerBullets.create(...)  // 每次射击创建新对象

enemyShoot() 第 189 行：
  const bullet = this.enemyBullets.create(...)  // 每次射击创建新对象

hitEnemy() 第 194 行：
  bullet.destroy()  // 击中后销毁对象
```

**优化思路**：
1. **初始化阶段**：预创建一定数量的子弹对象（对象池）
2. **射击时**：从池中取一个不活跃的子弹，激活并复用
3. **击中/超出屏幕**：不销毁，而是回收到池中（设为不活跃）
4. **循环复用**：对象可被重复使用，无需频繁分配/释放

**收益**：
- ✅ 减少内存分配开销
- ✅ 减少 GC 频率（预期 50% 以上改善）
- ✅ 性能提升 10-20%
- ✅ 支持更多子弹而不降帧

---

## 三、实施步骤清单

### 步骤 1：配置参数添加
**文件**：`src/config/GameConfig.js`

**位置**：在 `AUDIO` 配置之后添加新配置块

**新增内容**（伪代码）：
```
OBJECT_POOL: {
  PLAYER_BULLETS: 50,   // 玩家子弹池大小
  ENEMY_BULLETS: 100    // 敌人子弹池大小
}
```

---

### 步骤 2：对象池初始化
**文件**：`src/scenes/GameScene.js`

**位置**：`create()` 方法中，"创建子弹组" 之后（约第 48-49 行）

**操作**：在创建 `playerBullets` 和 `enemyBullets` 后，添加两个循环：
- 玩家子弹池循环：创建 `OBJECT_POOL.PLAYER_BULLETS` 个子弹
- 敌人子弹池循环：创建 `OBJECT_POOL.ENEMY_BULLETS` 个子弹
- 每个子弹设为不活跃和不可见

**伪代码**：
```
for (let i = 0; i < GameConfig.OBJECT_POOL.PLAYER_BULLETS; i++)
  创建子弹 → setActive(false) → setVisible(false)

for (let i = 0; i < GameConfig.OBJECT_POOL.ENEMY_BULLETS; i++)
  创建子弹 → setActive(false) → setVisible(false)
```

---

### 步骤 3：玩家射击逻辑改造
**文件**：`src/scenes/GameScene.js`

**位置**：`playerShoot()` 方法（约第 171-183 行）

**改造内容**：
- 旧代码：`this.playerBullets.create(...)`
- 新代码：使用 `getFirstDead(false)` 从池中取对象
- 判断对象存在后，才进行激活、位置设置、速度设置

**关键点**：
- `getFirstDead(false)` 返回第一个不活跃的子弹
- 如果池中所有子弹都在活跃，此函数返回 null
- 需要 null 判断，避免错误

---

### 步骤 4：敌人射击逻辑改造
**文件**：`src/scenes/GameScene.js`

**位置**：`enemyShoot()` 方法（约第 185-191 行）

**改造内容**：
- 与玩家射击类似改造
- 从敌人子弹池中取对象
- 激活、设置位置、设置速度

---

### 步骤 5：碰撞处理改造
**文件**：`src/scenes/GameScene.js`

**位置**：`hitEnemy()` 方法（约第 193-206 行）

**改造内容**：
- 旧代码：`bullet.destroy()`
- 新代码：改为回收（不销毁）
  - `bullet.setActive(false)`
  - `bullet.setVisible(false)`
  - `bullet.setVelocity(0, 0)` （停止移动，重要！）

**原因**：销毁会让对象彻底移除，对象池无法复用。改为隐藏+停止，对象保留在池中供复用。

---

### 步骤 6：清理逻辑改造
**文件**：`src/scenes/GameScene.js`

**位置**：`update()` 方法中的子弹清理部分（约第 122-132 行）

**改造内容**：
玩家子弹清理：
- 旧代码：检查 `bullet.y < 0` 后调用 `destroy()`
- 新代码：检查 `bullet.active && bullet.y < 0` 后调用 `setActive(false)`、`setVisible(false)`、`setVelocity(0, 0)`

敌人子弹清理：
- 旧代码：检查 `bullet.y > height` 后调用 `destroy()`
- 新代码：检查 `bullet.active && bullet.y > height` 后调用 `setActive(false)`、`setVisible(false)`、`setVelocity(0, 0)`

**原因**：避免销毁对象，改为回收到池中。

---

## 四、优化后测试计划

### 测试场景（与优化前相同）
- **持续时间**：30 秒
- **操作**：疯狂按空格键射击
- **目标**：最大化子弹创建/复用频率

### 测试方法
1. 实现对象池优化代码
2. 启动开发服务器：`npm start`
3. 打开浏览器 DevTools → Performance 标签
4. 进行相同的性能录制（30 秒疯狂射击）
5. 记录下方表格中的数据

### 优化后数据记录

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| **平均 FPS** | `___` | `___` | `___` |
| **最低 FPS** | `___` | `___` | `___` |
| **GC 事件数** | `___` | `___` | ↓ `___` 次 |
| **Peak Memory** | `___` | `___` | `___` |
| **Avg Memory** | `___` | `___` | `___` |

### 截图位置

- **优化后 FPS 曲线**：粘贴截图或描述
  ```
  [截图位置]
  ```

- **优化后 GC 事件密度**：粘贴截图或描述
  ```
  [截图位置]
  ```

- **优化后内存占用**：粘贴截图或描述
  ```
  [截图位置]
  ```

---

## 五、效果对比与分析

### 性能对比总结

**定性分析**：
- [ ] GC 事件明显减少
- [ ] FPS 更稳定（曲线更平坦）
- [ ] 内存占用更平稳（无明显波动）
- [ ] 游戏感觉更流畅

**定量分析**：

| 指标 | 改善幅度 | 备注 |
|------|---------|------|
| FPS 稳定性 | `___` % | (最低 FPS 更高或平均 FPS 更高) |
| GC 频率降低 | `___` % | (GC 事件数量减少比例) |
| 内存优化 | `___` % | (Peak Memory 或 Avg Memory 改善) |

### 结论

**总体评估**：
```
[对比优化前后的性能表现，总结改善效果]

优化亮点：
- [ ] 特别明显的改善点
- [ ] 预期外的收获
- [ ] 代码可维护性提升

潜在影响：
- [ ] 对游戏体验的正面影响
- [ ] 未来扩展空间（如支持更多子弹）
```

---

## 六、后续优化建议

完成对象池优化后，可考虑以下扩展：

1. **敌人对象池**
   - 敌人生成/消失也可使用对象池
   - 需要考虑敌人的初始化成本

2. **性能监控面板**
   - 添加实时显示活跃子弹数、池使用率
   - 便于开发调试和性能监控

3. **动态对象池大小调整**
   - 根据游戏进行情况动态增加池大小
   - 避免固定大小不足导致的性能下降

4. **难度递增优化**
   - 结合对象池，支持更高难度的子弹海
   - 基于当前性能动态调整敌人数量

---

## 附录：DevTools 录制技巧

### 如何找到 GC 事件
1. 录制完成后，查看 Performance 面板
2. 在时间线上找绿色向下的箭头 → 这就是 GC 事件
3. GC 事件越多，说明垃圾回收压力越大

### 如何读取内存占用
1. 在 Performance 录制面板中，下拉找 Memory 行
2. 观察蓝色曲线：
   - 上升 = 内存分配
   - 下降 = GC 回收
   - 频繁波动 = GC 压力大

### 如何导出性能报告
1. 录制完成后，右键点击录制数据
2. 选择 "Export" 或 "Save as"
3. 保存为 `.json` 文件备档

---

*文档创建时间: 2025-11-13*
*最后更新: 2025-11-13*
